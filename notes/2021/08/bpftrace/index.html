<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/tufte.css"> <link rel=stylesheet  href="/css/latex.css"> <link rel=stylesheet  href="/css/admonition.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>BPFTrace & Julia: An introduction to UProbes</title> <script defer data-domain=vchuravy.dev  src="https://plausible.io/js/plausible.js"></script> <div id=layout > <div id=menu > <ul> <li><a href="/">Home</a> <li><a href="/notes">Notes</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=bpftrace_and_julia ><a href="#bpftrace_and_julia" class=header-anchor >BPFTrace and Julia</a></h1> <div class=franklin-toc ><ol><li><a href="#probing_functions_using_uprobes">Probing functions using <code>uprobes</code></a><ol><li><a href="#a_note_on_ustack">A note on <code>ustack</code></a></ol><li><a href="#coming_up_next">Coming up next</a><ol><li><a href="#acknowledgments">Acknowledgments</a></ol></ol></div> <p>BPFTrace is an observability tool inspired by DTrace for Linux. It uses the eBPF infrastructure in the Linux kernel to implemented lightweight tracing of the kernel and applications. This note is written from a Linux perspective, but much of this should hold on systems with DTrace.</p> <p>The table below is taken from the <code>bpftrace</code> man page:</p> <table><tr><th align=center ><th align=center >kernel<th align=center >userland<tr><td align=center >static<td align=center >tracepoints<td align=center >USDT* probes<tr><td align=center >dynamic<td align=center >kprobes<td align=center >uprobes</table> <p>*USDT &#61; user-level statically defined tracing</p> <p>I will focus on userland for now, since that is the most useful feature for understanding applications, like Julia. The difference between <em>static</em> and <em>dynamic</em> comes down to whether the application is compiled with explicit tracepoints, which are static, or whether we are dynamically instrumenting functions in the application.</p> <p>The big selling point of BPFTrace is that it is lightweight and introduces next to no overhead until tracing is enabled, as well as being able to turn on tracing on a program that is already running.</p> <h2 id=probing_functions_using_uprobes ><a href="#probing_functions_using_uprobes" class=header-anchor >Probing functions using <code>uprobes</code></a></h2> <p>In this first exploration we will use dynamic probes called <code>uprobes</code> on function entries.</p> <p>Locate the library directory where <code>libjulia-internal.so</code> is located.</p> <pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=language-julia > realpath(joinpath(Sys.BINDIR, Base.LIBDIR, <span class=hljs-string >&quot;julia&quot;</span>))
</span>&quot;/usr/lib/julia&quot;</code></pre> <p>Using <code>nm</code> we can list all of the exported runtime functions of Julia.</p> <pre><code class="bash hljs">nm -D /usr/lib/julia/libjulia-internal.so</code></pre>
<p>All of these functions can be instrumented using a <code>uprobe</code>.</p>
<p>There are two kinds of UProbes.</p>
<ol>
<li><p><code>uprobe</code>: Execute on entry to a function.</p>

<li><p><code>uretprobe</code>: Executed on exit from a function.</p>

</ol>
<p>As an example we can look for GC related functions:</p>
<pre><code class="bash hljs">nm -D /usr/lib/julia/libjulia-internal.so | grep jl_gc_
0000000000015215 T jl_gc_add_finalizer
0000000000015221 T jl_gc_add_finalizer_th
000000000001522d T jl_gc_add_ptr_finalizer
0000000000015239 T jl_gc_alloc
0000000000015245 T jl_gc_alloc_0w
0000000000015251 T jl_gc_alloc_1w
000000000001525d T jl_gc_alloc_2w
0000000000015269 T jl_gc_alloc_3w
0000000000015275 T jl_gc_allocobj
0000000000015281 T jl_gc_alloc_typed
000000000001528d T jl_gc_big_alloc
...</code></pre>
<p>an alternative way to find all valid <code>uprobe</code> tracepoints is to use <code>bpftrace</code>:</p>
<pre><code class="julia hljs">sudo bpftrace -l &#x27;uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_*&#x27;
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_add_finalizer
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_add_finalizer_th
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_add_ptr_finalizer
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_0w
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_1w
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_2w
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_3w
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_page
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc_typed
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_allocobj
uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_big_alloc
...</code></pre>
<p>this is very helpful to confirm that <code>bpftrace</code> can actually find the function you want to instrument.</p>
<div class=admonition-note ><div class=admonition-title >Note</div>
<div class=admonition-body >To understand what each function does it is best to search for the name in the <code>src</code> directory of Julia.</div></div>
<p>Let us assume that we want to understand a Julia program&#39;s allocation behaviour better, and we know that <code>jl_gc_alloc</code> is the primary allocation function.</p>
<p>Looking at the Julia source code:</p>
<pre><code class="c hljs"><span class=hljs-type >jl_value_t</span>* <span class="hljs-title function_">jl_gc_alloc</span><span class=hljs-params >(<span class=hljs-type >jl_ptls_t</span> ptls, <span class=hljs-type >size_t</span> sz, <span class=hljs-type >void</span> *ty)</span></code></pre>
<p>I see that it takes the current <code>ptls</code>, a size <code>sz</code> and a <code>void* ty</code> which is the type of the Julia object to allocate. For now the only interesting argument is <code>sz</code>.</p>
<p>The function <code>allocator</code> is going to run forever and allocate an array of size <code>N</code> bytes.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> allocator(range)
    <span class=hljs-keyword >while</span> <span class=hljs-literal >true</span>
        N = rand(range)
        buf = <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >UInt8</span>}(<span class=hljs-literal >undef</span>, N)
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<p>In one terminal I am going to run my Julia process with:</p>
<pre><code class="bash hljs">julia -L allocator.jl -e <span class=hljs-string >&quot;allocator(64:128)&quot;</span></code></pre>
<p>where <code>allocator.jl</code> contains the function from above.</p>
<div class=admonition-note ><div class=admonition-title >Note  Paths to shared library</div>
<div class=admonition-body >As far as I know <code>bpftrace</code> expects the path to the library &#40;or the pid of     the process to instrument&#41;. It accepts either a relative or absolute path.</div></div>
<div class=admonition-note ><div class=admonition-title >Note  Automatic resolution of shared library paths</div>
<div class=admonition-body >After https://github.com/iovisor/bpftrace/pull/1971 <code>bpftrace</code> now supports automatic resolution of library paths and you no longer need to     provide absolute or relative paths. This note was written when that was still the case and we will use relative paths throughout.</div></div>
<p><code>bpftrace</code> has its own language inspired by <code>dtrace</code>. In the following example we install a <code>uprobe</code> on the function <code>jl_gc_alloc</code>.</p>
<p><code>bpftrace</code> will instrument all running processes on the OS that are using a certain library. Instead of using a library you can also use a PID.</p>
<p>For simple bpftrace programs you can write them directly as part of the command line:</p>
<pre><code class="bash hljs">➜  ~ sudo bpftrace -e <span class=hljs-string >&quot;uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc { @[pid] = hist(arg1); }&quot;</span>
Attaching 1 probe...
c^C

@[2955269]:
[16, 32)             995 |@@@@@@@@@@                                          |
[32, 64)             448 |@@@@                                                |
[64, 128)           1936 |@@@@@@@@@@@@@@@@@@@@                                |
[128, 256)          4891 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[256, 512)            10 |                                                    |
[512, 1K)            226 |@@                                                  |
[1K, 2K)               2 |                                                    |
[2K, 4K)               2 |</code></pre>
<p>Or you can write a script, take the snippet below and write it to a file called <code>trace_gc_alloc.bt</code>.</p>
<pre><code class="julia hljs"><span class=hljs-comment >#!/usr/bin/env bpftrace</span>

BEGIN
{
    printf(<span class=hljs-string >&quot;Tracing Julia GC Allocations... Hit Ctrl-C to end.\n&quot;</span>);
}

uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc
{
    <span class=hljs-meta >@allocations</span>[pid] = hist(arg1);
}</code></pre>
<p>and then execute <code>bpftrace</code>:</p>
<pre><code class="bash hljs">➜  ~ sudo bpftrace trace_gc_alloc.bt
Attaching 2 probes...
Tracing Julia GC Allocations... Hit Ctrl-C to end.
^C

@allocations[2955269]:
[16, 32)             995 |@@@@@@@@@@@@@                                       |
[32, 64)             448 |@@@@@@                                              |
[64, 128)           1926 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
[128, 256)          3711 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[256, 512)             8 |                                                    |
[512, 1K)            226 |@@@                                                 |
[1K, 2K)               2 |                                                    |
[2K, 4K)               2 |                                                    |</code></pre>
<h3 id=a_note_on_ustack ><a href="#a_note_on_ustack" class=header-anchor >A note on <code>ustack</code></a></h3>
<p><code>bpftrace</code> exposes the option to collect the stack of the user application when a probe fires.</p>
<pre><code class="julia hljs">sudo bpftrace -e <span class=hljs-string >&quot;uprobe:/usr/lib/julia/libjulia-internal.so:jl_gc_alloc { @[ustack] = count(); }&quot;</span>
[sudo] password <span class=hljs-keyword >for</span> vchuravy:
Attaching <span class=hljs-number >1</span> probe...
^C

@[
    jl_gc_alloc+<span class=hljs-number >0</span>
    japi1_Dict_16786.clone_1+<span class=hljs-number >159</span>
    <span class=hljs-number >0x7f993e3a9e32</span>
    <span class=hljs-number >0x7f993e3aa04a</span>
    <span class=hljs-number >0x7f993e40832d</span>
    <span class=hljs-number >0x7f993e38600e</span>
    <span class=hljs-number >0x7f993e3877b9</span>
    <span class=hljs-number >0x7f993e38a02c</span>
    <span class=hljs-number >0x7f993e38a326</span>
    do_call+<span class=hljs-number >166</span>
    eval_value+<span class=hljs-number >1135</span>
    eval_body+<span class=hljs-number >930</span>
    jl_interpret_toplevel_thunk+<span class=hljs-number >232</span>
    jl_toplevel_eval_flex+<span class=hljs-number >738</span>
    jl_toplevel_eval_flex+<span class=hljs-number >1325</span>
    jl_toplevel_eval_in+<span class=hljs-number >170</span>
    japi1_eval_user_input_18975.clone_1.clone_2+<span class=hljs-number >1074</span>
    japi1_repl_backend_loop_17983.clone_1.clone_2+<span class=hljs-number >936</span>
    japi1_start_repl_backend_19196.clone_1+<span class=hljs-number >127</span>
    japi1_run_repl_18018.clone_1+<span class=hljs-number >25</span>
    julia_YY<span class=hljs-number >.874_41531</span>.clone_1+<span class=hljs-number >1574</span>
    jfptr_YY<span class=hljs-number >.874_41532</span>.clone_1+<span class=hljs-number >9</span>
    jl_f__call_latest+<span class=hljs-number >71</span>
    julia_run_main_repl_32598.clone_1.clone_2+<span class=hljs-number >2249</span>
    julia_exec_options_29068.clone_1.clone_2+<span class=hljs-number >23966</span>
    julia__start_34288.clone_1+<span class=hljs-number >655</span>
]: <span class=hljs-number >1</span>
@[
    jl_gc_alloc+<span class=hljs-number >0</span>
    <span class=hljs-number >0x7f993e40850f</span>
    <span class=hljs-number >0x7f993e38600e</span>
    <span class=hljs-number >0x7f993e3877b9</span>
    <span class=hljs-number >0x7f993e38a02c</span>
    <span class=hljs-number >0x7f993e38a326</span>
    do_call+<span class=hljs-number >166</span>
    eval_value+<span class=hljs-number >1135</span>
    eval_body+<span class=hljs-number >930</span>
    jl_interpret_toplevel_thunk+<span class=hljs-number >232</span>
    jl_toplevel_eval_flex+<span class=hljs-number >738</span>
    jl_toplevel_eval_flex+<span class=hljs-number >1325</span>
    jl_toplevel_eval_in+<span class=hljs-number >170</span>
    japi1_eval_user_input_18975.clone_1.clone_2+<span class=hljs-number >1074</span>
    japi1_repl_backend_loop_17983.clone_1.clone_2+<span class=hljs-number >936</span>
    japi1_start_repl_backend_19196.clone_1+<span class=hljs-number >127</span>
    japi1_run_repl_18018.clone_1+<span class=hljs-number >25</span>
    julia_YY<span class=hljs-number >.874_41531</span>.clone_1+<span class=hljs-number >1574</span>
    jfptr_YY<span class=hljs-number >.874_41532</span>.clone_1+<span class=hljs-number >9</span>
    jl_f__call_latest+<span class=hljs-number >71</span>
    julia_run_main_repl_32598.clone_1.clone_2+<span class=hljs-number >2249</span>
    julia_exec_options_29068.clone_1.clone_2+<span class=hljs-number >23966</span>
    julia__start_34288.clone_1+<span class=hljs-number >655</span>
]: <span class=hljs-number >1</span>
@[
    jl_gc_alloc+<span class=hljs-number >0</span>
    julia_YY.readdirYY<span class=hljs-number >.22_35563</span>.clone_1.clone_2+<span class=hljs-number >316</span>
    julia_tryf_35829.clone_1.clone_2+<span class=hljs-number >367</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >185</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia_YY<span class=hljs-number >.25_35391</span>.clone_1+<span class=hljs-number >124</span>
    start_task+<span class=hljs-number >235</span>
]: <span class=hljs-number >1</span>
@[
    jl_gc_alloc+<span class=hljs-number >0</span>
    jl_array_grow_end+<span class=hljs-number >299</span>
    julia_sortNOT._46922.clone_1.clone_2+<span class=hljs-number >164</span>
    julia_YY.readdirYY<span class=hljs-number >.22_35563</span>.clone_1.clone_2+<span class=hljs-number >339</span>
    julia_tryf_35829.clone_1.clone_2+<span class=hljs-number >367</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >185</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >985</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >985</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >985</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia__walkdir_35550.clone_1.clone_2+<span class=hljs-number >985</span>
    jfptr__walkdir_35551.clone_1+<span class=hljs-number >17</span>
    julia_YY<span class=hljs-number >.25_35391</span>.clone_1+<span class=hljs-number >124</span>
    start_task+<span class=hljs-number >235</span>
]: <span class=hljs-number >1</span>
@[
    jl_gc_alloc+<span class=hljs-number >0</span>
    <span class=hljs-number >0x7f993e3ab245</span>
    <span class=hljs-number >0x7f993e3ab649</span>
    jl_apply_generic+<span class=hljs-number >506</span>
    <span class=hljs-number >0x7f993e4083cc</span>
    <span class=hljs-number >0x7f993e38600e</span>
    <span class=hljs-number >0x7f993e3877b9</span>
    <span class=hljs-number >0x7f993e38a02c</span>
    <span class=hljs-number >0x7f993e38a326</span>
    do_call+<span class=hljs-number >166</span>
    eval_value+<span class=hljs-number >1135</span>
    eval_body+<span class=hljs-number >930</span>
    jl_interpret_toplevel_thunk+<span class=hljs-number >232</span>
    jl_toplevel_eval_flex+<span class=hljs-number >738</span>
    jl_toplevel_eval_flex+<span class=hljs-number >1325</span>
    jl_toplevel_eval_in+<span class=hljs-number >170</span>
    japi1_eval_user_input_18975.clone_1.clone_2+<span class=hljs-number >1074</span>
    japi1_repl_backend_loop_17983.clone_1.clone_2+<span class=hljs-number >936</span>
    japi1_start_repl_backend_19196.clone_1+<span class=hljs-number >127</span>
    japi1_run_repl_18018.clone_1+<span class=hljs-number >25</span>
    julia_YY<span class=hljs-number >.874_41531</span>.clone_1+<span class=hljs-number >1574</span>
    jfptr_YY<span class=hljs-number >.874_41532</span>.clone_1+<span class=hljs-number >9</span>
    jl_f__call_latest+<span class=hljs-number >71</span>
    julia_run_main_repl_32598.clone_1.clone_2+<span class=hljs-number >2249</span>
    julia_exec_options_29068.clone_1.clone_2+<span class=hljs-number >23966</span>
    julia__start_34288.clone_1+<span class=hljs-number >655</span>
]: <span class=hljs-number >1</span>
...</code></pre>
<p>As you can see, there are function pointers in the stack trace whose names are not resolved. These are JIT-compiled user functions, and BPFTrace currently doesn&#39;t know how to symbolize them. There is an <a href="https://dxuuu.xyz/stack-symbolize.html">initial design proposal</a> that might mitigate that in the future.</p>
<h2 id=coming_up_next ><a href="#coming_up_next" class=header-anchor >Coming up next</a></h2>
<p>I am planning to write at least two more notes on using BPFTrace and Julia, the next will focus on how to use the USDT tracepoints added in Julia 1.8 and the one after that on how to use UProbes.jl to instrument Julia applications themselves.</p>
<h3 id=acknowledgments ><a href="#acknowledgments" class=header-anchor >Acknowledgments</a></h3>
<p>Thanks to Nathan Daly for reading early versions of this note and giving great feedback.</p>
    <script src="https://utteranc.es/client.js" repo="vchuravy/vchuravy.github.io"
        issue-term=pathname  theme=github-light  crossorigin=anonymous 
        async>
    </script>

<div class=page-foot >
  <div class=copyright >
    &copy; Valentin Churavy. Last modified: October 03, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
        </div> 
    </div>